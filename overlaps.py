# -*- coding: utf-8 -*-
#! /bin/env python
import sys,os
import numpy as np
import pylab as pl
from matplotlib.font_manager import FontProperties
from itertools import permutations , combinations

import tdasolver as td
import rgfunctions as rf
import richardsongaudin as rg

class State_Calculator(object):
  """
  class that calculates the state by making use of the calc_coef(self, tdasol) that every instance of equation need to have
  """
  def __init__(self,equation,npairs,tdadict = None):
    self.eqvars = equation
    self.npair = npairs
    if tdadict == None:
      if isinstance(equation,td.TdaSolver):
        self.tdadict = self.eqvars.tdadict
      else:
        self.tdadict =  dict(zip(range(self.npair) , [1] * self.npair))
    else:
      self.tdadict = tdadict
    self.state = self.construct_state()

  def set_tdadict(self,tdadict):
    self.eqvars.set_tdadict(tdadict)

  def calc_coeflist(self):
    oplossingen = self.eqvars.get_solutions()
    calclist = []
    for i in self.tdadict.keys():
      if self.tdadict[i] != 0:
        for k in range(self.tdadict[i]):
          calclist.append( self.eqvars.calc_coef(oplossingen[i])) 
    return calclist

  def calc_statecoef(self,state , coeflist ):
    """
    calculates the coefficient of a sp state (state) in the tdastate with apair pairs making use of coeflist which contains  arrays of calcxicoefficients with constant  sol but changing sp level as in the summation for the creation of the state
    """
    perms = permutations(state)
    totcoef = 0.
    for perm in perms:
      i = 0
      coef = 1.
      for coefs in coeflist:
        coef *= coefs[perm[i]]
        #print coef , perm , coefs[perm[i]]
        i += 1
      totcoef += coef
    #print totcoef
    return totcoef

  def construct_state(self):
    """
    Constructs the vector with the number of pairs that self.dict defines.
    TO DO generalize for general degeneracies
    """
    nlevel = len(self.eqvars.energiel)
    coeflist = self.calc_coeflist()
    assert self.npair < sum(self.eqvars.ontaardingen), 'number of pairs is bigger then the state can contain'
    assert sum(self.eqvars.ontaardingen) == 2*len(self.eqvars.energiel), 'the degeneracy is larger then 2 please update the construction of the state to general degeneracys before moving along'
    #picklist = []
    #for i in range(nlevel):
    #  picklist += [i] * self.eqvars.ontaardingen[i]/2
    spstates = combinations( np.arange(nlevel),self.npair)
    dim = rf.binoml(nlevel,self.npair)
    state = np.zeros(dim,complex)
    i = 0
    for state_id in spstates:
      state[i] = self.calc_statecoef(state_id, coeflist)  
      i += 1 
    assert i == dim , 'i = %g , dim-1 = %g' %(i , dim-1) 
    state = state / np.linalg.norm(state)
    return state

  def calc_overlap(self, state):
    print 'calculating overlap '
    return np.dot(self.state , state.state).real

def create_tdafile(rgeq , dvar , begin = -0.0001 , end = -2. , step = -0.001 , filen = 'alltdas.dat'):
  rsolve = rg.RichardsonSolver(rgeq) # quick hack to let the richardson solver class generate the appropriate tdasolver 
  tda = rsolve.tda
  file = open(filen , 'w')
  file.write(str(tda))
  file.write('#%s\ttda1 .... tdan\n' %dvar)
  while(begin > end):
    tda.setvar(dvar, begin)
    tda.bisect_tda()
    file.write('%f %s\n' %(tda.getvar(dvar), '  '.join(map(str,tda.get_solutions()))))
    begin += step
  file.close()

def list_to_dict(tdalist, nlevel):
  return dict(zip(np.arange(nlevel), tdalist))

def readrgvarsplote(plotf ,npair, linespacing = 1):
  """
  function that reads back in the rgvars out of an plotenergy.dat file generated by generating_datak
  """
  for i in range(linespacing):
    line = plotf.readline()
    if line == '':
      return None , None #end of file is reached
  while line[0]== '#':
    line = plotf.readline()
    if line == '':
      return None , None #end of file is reached
  data = line.split()
  afhvar = float(data[0])
  mixdata = map(float,data)[3:]
  redata = mixdata[:2*npair:2]
  imdata = mixdata[1:2*npair:2]
  assert(len(redata) == len(imdata))
  rgvars = np.empty(len(redata),complex)
  rgvars.real = redata
  rgvars.imag = imdata
  return afhvar , rgvars

def plotoverlaps(tdadictlist , cvar , filen = 'overlap.dat', legend = True):
  plotf = open(filen, 'r')
  cvar = '|'+cvar + '|'
  try:
    dataf = np.loadtxt(plotf,comments = '#')
  except:
    dataf = np.array([])
    plotf.seek(0) #go back to beginning of file
    for line in plotf:
      if line[0] == '#':
        continue
      pline = np.array(map(float,line.split()))
      if len(dataf) <= 1:
        dataf = pline
      else:
        try:
          dataf = np.vstack((dataf,pline))
        except:
          continue
    print np.shape(dataf)
  pl.figure()
  ax = pl.subplot(111)
  for i in xrange(len(dataf[0,:])-1):
    if legend == True:
      ax.plot(abs(dataf[:,0]),abs(dataf[:,i+1]), label = str(tdadictlist[i]))
    else:
      ax.plot(np.log(abs(dataf[:,0])),abs(dataf[:,i+1]))
  if legend == True:
    writelegend(ax , cvar)
  else:
    writetext(ax)
  pl.ylabel('Overlaps RG with tdastate')
  pl.title('Overlaps tdastates with Richardson-Gaudin ground-state')
  pl.savefig('%s.png' %filen.strip('.dat'))
  pl.close()

def writelegend(ax,cvar):
  box = ax.get_position()
  ax.set_position([box.x0 - box.width * 0.05 , box.y0 , box.width * 0.80 , box.height])
  fontL = FontProperties()
  fontL.set_size('x-small')
  ax.legend(loc = 2 , prop = fontL , bbox_to_anchor = (1.00,1.00) , fancybox = True , shadow = True)
  pl.xlabel(cvar )

def writetext(ax , fs= 10):
  ax.text(-6.901,0.95,r'(1111110$\ldots0$)' , horizontalalignment = 'left', fontsize = fs)
  ax.text(-6.901,0.80,r'(111120$\ldots0$)' , verticalalignment = 'bottom' , horizontalalignment = 'left', fontsize = fs)
  ax.text(-6.9011,0.60,r'(11130$\ldots$0)' , verticalalignment = 'bottom' , horizontalalignment = 'left', fontsize = fs)
  ax.text(-6.9011,0.53,r'(211110$\ldots$0)' , rotation = 5, horizontalalignment = 'left', fontsize = fs)
  ax.text(0.91,0.65,r'(60$\ldots$0)' , horizontalalignment = 'right', fontsize = fs)
  ax.text(1.05,0.42,r'(510$\ldots$0)' , horizontalalignment = 'left', fontsize = fs)
  ax.text(-1.30,0.90,r'(150$\ldots$0)' , rotation =-60 , fontsize = fs , horizontalalignment = 'left')
  ax.text(1.43,0.28,r'(1140$\ldots$0)' , rotation =-20 ,horizontalalignment = 'right', fontsize = fs)
  ax.text(0.910, 0.20,r'(4110$\ldots$0)' , rotation = -20 ,horizontalalignment = 'right', fontsize = fs)
  ax.text(-6.9011,0.39,r'(31110$\ldots$0)' ,horizontalalignment = 'left', fontsize = fs)
  ax.text(1.43 ,0.132 ,r'(21120$\ldots$0)' , rotation = -18 ,horizontalalignment = 'right', fontsize = fs) #, color = 'black', style = 'italic')
  pl.xlabel( 'log|g|')


def windfile(infile , waardeafh , nauw = 1e-7):
  while True and waardeafh != None:
    line = infile.readline()
    test = line.split()
    if test[0][0] != '#':
      if (waardeafh >= float(test[0])-nauw/2. and waardeafh <= float(test[0])+nauw/2. ) or waardeafh == None:
        waarden = map(float,line.split())
        break
  return infile

def main():
  #create_tdafile(rgeq , 'g' ,filen = 'alltdasredbcspicketfence.dat')
  energiel = np.arange(1,13)
  ont = np.ones(12)*2.
  sen = np.zeros(12)
  apair = 6
  g = -11.001000 
  cvar = 'eta'
  eta = 1.
  filen = 'plotenergygbig.dat'
  outputf = 'overlapfac5ti.dat' 
  richvars = open(filen,'r')
  outfile = open(outputf, 'w')
  tdadictlist = [{0:1 , 1:1 , 2:1 , 3:1 ,4:1 , 5:1}, {0:6} , {0:1 , 1:5} , {0:5 , 1:1},{0:1 , 1:1 , 2:4} ,{0:1 , 1:1 , 2:1 , 3:1 ,4:2},{0:4 , 1:1 , 2:1}, {0:2 , 1:1 , 2:1 , 3: 2}, {0:2 , 1:1 , 2:1 , 3:1 ,4:1},{0:3 , 1:1 , 2:1 , 3:1 },{0:1 , 1:1 , 2:1 , 3:3 } ]
  richvars = windfile(richvars , g)
  dvar , rgvars = readrgvarsplote(richvars , apair,linespacing = 1) 
  rgeq = rg.RichFacInt(energiel, ont , sen , g ,eta, apair,xi = 1.,rgsol = rgvars )
  rgeq.setvar(cvar,dvar)
  tda = rg.RichardsonSolver(rgeq).tda
  tda.bisect_tda()
  outfile.write(str(rgeq))
  outfile.write('#%s  %s\n' %(cvar ,'  '.join(map(str,tdadictlist))))
  while dvar != None:
    overlaplist = []
    for tdad in tdadictlist:
      tdastate = State_Calculator(tda , apair , tdadict =tdad)
      rgeqstate = State_Calculator(rgeq, apair)
      ovlap = rgeqstate.calc_overlap(tdastate)
      overlaplist.append(ovlap)
    outfile.write('%f  %s\n' %(dvar , '  '.join(map(str,overlaplist))) )
    dvar , rgvars = readrgvarsplote(richvars , apair ,linespacing = 100000) 
    rgeq.setvar(cvar,dvar)
    rgeq.rgsolutions = rgvars
    tda.setvar(cvar , dvar)
    tda.bisect_tda()

  richvars.close()
  outfile.close()
  plotoverlaps(tdadictlist ,cvar , filen = outputf)

if __name__ == "__main__":
  #main()
  tdadictlist = [{0:1 , 1:1 , 2:1 , 3:1 ,4:1 , 5:1}, {0:6} , {0:1 , 1:5} , {0:5 , 1:1},{0:1 , 1:1 , 2:4} ,{0:1 , 1:1 , 2:1 , 3:1 ,4:2},{0:4 , 1:1 , 2:1}, {0:2 , 1:1 , 2:1 , 3: 2}, {0:2 , 1:1 , 2:1 , 3:1 ,4:1},{0:3 , 1:1 , 2:1 , 3:1 },{0:1 , 1:1 , 2:1 , 3:3 }]
  plotoverlaps(tdadictlist , 'g' , filen = 'overlapfacintpicketfence.dat', legend = False)

